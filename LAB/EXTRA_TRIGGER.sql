
			--AFTER TRIGGER

CREATE TABLE EMPLOYEEDETAILS
(
	EmployeeID Int Primary Key,
	EmployeeName Varchar(100) Not Null,
	ContactNo Varchar(100) Not Null,
	Department Varchar(100) Not Null,
	Salary Decimal(10,2) Not Null,
	JoiningDate DateTime Null
)


CREATE TABLE EmployeeLogs (
    LogID INT PRIMARY KEY IDENTITY(1,1),
    EmployeeID INT NOT NULL,
	 EmployeeName VARCHAR(100) NOT NULL,
    ActionPerformed VARCHAR(100) NOT NULL,
    ActionDate DATETIME NOT NULL
);

--1)	Create a trigger that fires AFTER INSERT, UPDATE, and DELETE operations on the EmployeeDetails table to display the message "Employee record inserted", "Employee record updated", "Employee record deleted"

			--INSERT
CREATE TRIGGER TR_EMPLYOEE_INSERT
ON EMPLOYEEDETAILS
AFTER INSERT
AS
BEGIN
	PRINT('Employee record inserted');
END

INSERT INTO EMPLOYEEDETAILS VALUES(2,'VANITA',1234567890,'CSE',80000,'2024-8-18')

SELECT * FROM EMPLOYEEDETAILS

DROP TRIGGER TR_EMPLYOEE_INSERT

			--UPDATE
CREATE TRIGGER TR_EMPLYOEE_UPDATE
ON EMPLOYEEDETAILS
AFTER UPDATE
AS
BEGIN
	PRINT('Employee record updated');
END

UPDATE EMPLOYEEDETAILS
SET EmployeeName = 'DISHA'
WHERE EMPLOYEEID = 2

SELECT * FROM EMPLOYEEDETAILS

DROP TRIGGER TR_EMPLYOEE_UPDATE

			--DELETE
CREATE TRIGGER TR_EMPLYOEE_DELETE
ON EMPLOYEEDETAILS
AFTER DELETE
AS
BEGIN
	PRINT('Employee record deleted');
END

DELETE FROM EMPLOYEEDETAILS WHERE EMPLOYEEID = 2

SELECT * FROM EMPLOYEEDETAILS

DROP TRIGGER TR_EMPLYOEE_DELETE

--2)	Create a trigger that fires AFTER INSERT, UPDATE, and DELETE operations on the EmployeeDetails table to log all operations into the EmployeeLog table.

	--INSERT
CREATE TRIGGER TR_EMPLOYEE_AFTER_INSERT
ON EMPLOYEEDETAILS
AFTER INSERT
AS
BEGIN
	DECLARE @EMPLOYEEID INT,@EMPLOYEENAME VARCHAR(50)
	SELECT @EMPLOYEEID = EMPLOYEEID FROM INSERTED
	SELECT @EMPLOYEENAME = EMPLOYEENAME FROM INSERTED

	INSERT INTO EMPLOYEELOGS VALUES(@EMPLOYEEID,@EMPLOYEENAME,'INSERT',GETDATE())
END

INSERT INTO EMPLOYEEDETAILS VALUES(3,'KHUSHI',1234567890,'CSE',80000,'2024-8-18')

SELECT * FROM EMPLOYEEDETAILS
SELECT * FROM EMPLOYEELOGS

DROP TRIGGER TR_EMPLOYEE_AFTER_INSERT

   --UPDATE

CREATE TRIGGER TR_EMPLOYEE_AFTER_UPDATE
ON EMPLOYEEDETAILS
AFTER UPDATE
AS
BEGIN
	DECLARE @EMPLOYEEID INT,@EMPLOYEENAME VARCHAR(50)
	SELECT @EMPLOYEEID = EMPLOYEEID FROM INSERTED
	SELECT @EMPLOYEENAME = EMPLOYEENAME FROM INSERTED

	INSERT INTO EMPLOYEELOGS VALUES(@EMPLOYEEID,@EMPLOYEENAME,'INSERT',GETDATE())
END

UPDATE EMPLOYEEDETAILS
SET EmployeeName = 'NIDHI'
WHERE EmployeeID = 2

SELECT * FROM EMPLOYEEDETAILS
SELECT * FROM EMPLOYEELOGS

DROP TRIGGER TR_EMPLOYEE_AFTER_UPDATE

	--DELETE

CREATE TRIGGER TR_EMPLOYEE_AFTER_DELETE
ON EMPLOYEEDETAILS
AFTER DELETE
AS
BEGIN
	DECLARE @EMPLOYEEID INT,@EMPLOYEENAME VARCHAR(50)
	SELECT @EMPLOYEEID = EMPLOYEEID FROM DELETED
	SELECT @EMPLOYEENAME = EMPLOYEENAME FROM DELETED

	INSERT INTO EMPLOYEELOGS VALUES(@EMPLOYEEID,@EMPLOYEENAME,'DELETE',GETDATE())
END

DELETE FROM EMPLOYEEDETAILS WHERE EmployeeID = 1

SELECT * FROM EMPLOYEEDETAILS
SELECT * FROM EMPLOYEELOGS

DROP TRIGGER TR_EMPLOYEE_AFTER_DELETE

--3)	Create a trigger that fires AFTER INSERT to automatically calculate the joining bonus (10% of the salary) for new employees and update a bonus column in the EmployeeDetails table.

CREATE TRIGGER TR_EMPLOYEE_UPDATE_BONUS
ON EMPLOYEEDETAILS
AFTER INSERT
AS
BEGIN
	DECLARE @SALARY DECIMAL(10,2),@EMPLOYEEID INT
	SELECT @SALARY = SALARY FROM INSERTED
	SELECT @EMPLOYEEID = EMPLOYEEID FROM INSERTED


	UPDATE EMPLOYEEDETAILS
	SET SALARY = @SALARY+@SALARY*0.1
	WHERE EMPLOYEEID = @EMPLOYEEID

END

INSERT INTO EMPLOYEEDETAILS VALUES(4,'KHUSHI',1234567890,'CSE',80000,'2024-8-18')

SELECT * FROM EMPLOYEEDETAILS
SELECT * FROM EMPLOYEELOGS

DROP TRIGGER TR_EMPLOYEE_UPDATE_BONUS

--4)	Create a trigger to ensure that the JoiningDate is automatically set to the current date if it is NULL during an INSERT operation.

CREATE TRIGGER TR_UPDATE_JOININGDATE_EMPLOYEE
ON EMPLOYEEDETAILS
AFTER UPDATE
AS
BEGIN
	DECLARE @JOININGDATE DATETIME , @EMPLOYEEID INT
	SELECT @JOININGDATE = JOININGDATE FROM INSERTED
		UPDATE EMPLOYEEDETAILS
		SET JOININGDATE = GETDATE()
		WHERE JOININGDATE IS NULL
END

	UPDATE EMPLOYEEDETAILS
		SET JOININGDATE = NULL
		WHERE EMPLOYEEID = 3

SELECT * FROM EMPLOYEEDETAILS
SELECT * FROM EMPLOYEELOGS

DROP TRIGGER TR_UPDATE_JOININGDATE_EMPLOYEE

--5)	Create a trigger that ensure that ContactNo is valid during insert and update (Like ContactNo length is 10)

CREATE TRIGGER TR_UPDATE_JOININGDATE_EMPLOYEE
ON EMPLOYEEDETAILS
AFTER UPDATE
AS
BEGIN
	DECLARE @CONTACT INT
	SELECT @CONTACT = CONTACTNO FROM INSERTED
	IF LEN(@CONTACT) = 10
	BEGIN
		INSERT INTO EMPLOYEEDETAILS VALUES(2,'VANITA',1234567890,'CSE',80000,'2024-8-18')
	END
	ELSE
		PRINT('INVALID CONTACT NUMBER')
END

	

SELECT * FROM EMPLOYEEDETAILS
SELECT * FROM EMPLOYEELOGS

DROP TRIGGER TR_UPDATE_JOININGDATE_EMPLOYEE




			--INSTEAD OF TRIGGER


CREATE TABLE Movies (
    MovieID INT PRIMARY KEY,
    MovieTitle VARCHAR(255) NOT NULL,
    ReleaseYear INT NOT NULL,
    Genre VARCHAR(100) NOT NULL,
    Rating DECIMAL(3, 1) NOT NULL,
    Duration INT NOT NULL
);

CREATE TABLE MoviesLog
(
	LogID INT PRIMARY KEY IDENTITY(1,1),
	MovieID INT NOT NULL,
	MovieTitle VARCHAR(255) NOT NULL,
	ActionPerformed VARCHAR(100) NOT NULL,
	ActionDate	DATETIME  NOT NULL
);


--1.	Create an INSTEAD OF trigger that fires on INSERT, UPDATE and DELETE operation on the Movies table. For that, log all operations performed on the Movies table into MoviesLog.

	--INSERT

CREATE TRIGGER TR_INSTEAD_OF_INSERT_MOVIE
ON MOVIES
INSTEAD OF INSERT
AS
BEGIN
	DECLARE @MOVIEID INT,@MOVIETITLE VARCHAR(50)
	SELECT @MOVIEID = MOVIEID FROM INSERTED
	SELECT @MOVIETITLE = MOVIETITLE FROM INSERTED

	INSERT INTO MOVIESLOG VALUES(@MOVIEID,@MOVIETITLE,'INSERT',GETDATE())
END

INSERT INTO MOVIES VALUES(1,'PK',2010,'ABC',2.5,2)

SELECT * FROM Movies
SELECT * FROM MOVIESLOG

DROP TRIGGER TR_INSTEAD_OF_INSERT_MOVIE

   --UPDATE

CREATE TRIGGER TR_PERSON_INSTEAD_OF_UPDATE_MOVIE
ON MOVIES
INSTEAD OF UPDATE
AS
BEGIN
	DECLARE @MOVIEID INT,@MOVIETITLE VARCHAR(50)
	SELECT @MOVIEID = MOVIEID FROM INSERTED
	SELECT @MOVIETITLE = MOVIETITLE FROM INSERTED

	INSERT INTO MOVIESLOG VALUES(@MOVIEID,@MOVIETITLE,'UPDATE',GETDATE())
END

UPDATE MOVIES
SET MOVIETITLE = 'DISHA'
WHERE MOVIEID = 1

SELECT * FROM Movies
SELECT * FROM MOVIESLOG

DROP TRIGGER TR_PERSON_INSTEAD_OF_UPDATE_MOVIE

	--DELETE

CREATE TRIGGER TR_PERSON_INSTEAD_OF_DELETE_MOVIE
ON MOVIES
INSTEAD OF DELETE
AS
BEGIN
	DECLARE @MOVIEID INT,@MOVIETITLE VARCHAR(50)
	SELECT @MOVIEID = MOVIEID FROM DELETED
	SELECT @MOVIETITLE = MOVIETITLE FROM DELETED

	INSERT INTO MOVIESLOG VALUES(@MOVIEID,@MOVIETITLE,'DELETE',GETDATE())
END

DELETE FROM MOVIES WHERE MOVIEID = 1

SELECT * FROM Movies
SELECT * FROM MOVIESLOG

DROP TRIGGER TR_PERSON_INSTEAD_OF_DELETE_MOVIE

--2.	Create a trigger that only allows to insert movies for which Rating is greater than 5.5 .

CREATE TRIGGER TR_INSERT_MOVIES_RATING
ON MOVIES
INSTEAD OF INSERT
AS
BEGIN
	DECLARE @MOVIEID INT,@MOVIETITLE VARCHAR(50),@RATE DECIMAL(2,1)
	SELECT @MOVIEID = MOVIEID FROM INSERTED
	SELECT @MOVIETITLE = MOVIETITLE FROM INSERTED
	SELECT @RATE = RATING FROM INSERTED
	IF @RATE>5.5
		INSERT INTO MOVIESLOG VALUES(@MOVIEID,@MOVIETITLE,'INSERT',GETDATE())
END

INSERT INTO MOVIES VALUES(3,'PK',2010,'ABC',7.5,2)

SELECT * FROM Movies
SELECT * FROM MOVIESLOG

DROP TRIGGER TR_INSERT_MOVIES_RATING

--3.	Create trigger that prevent duplicate 'MovieTitle' of Movies table and log details of it in MoviesLog table.

--4.	Create trigger that prevents to insert pre-release movies.

--5.	Develop a trigger to ensure that the Duration of a movie cannot be updated to a value greater than 120 minutes (2 hours) to prevent unrealistic entries.

